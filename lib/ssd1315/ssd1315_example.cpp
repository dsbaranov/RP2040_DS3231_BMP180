#include "ssd1315.h"

// Simple 8x8 font for ASCII characters 32-126
const uint8_t font8x8[95][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // ' '
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // '!'
    {0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // '"'
    {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00}, // '#'
    {0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00}, // '$'
    {0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00}, // '%'
    {0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00}, // '&'
    {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // '''
    {0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00}, // '('
    {0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00}, // ')'
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // '*'
    {0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00}, // '+'
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x06, 0x00}, // ','
    {0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00}, // '-'
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // '.'
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00}, // '/'
    {0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00}, // '0'
    {0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00}, // '1'
    {0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00}, // '2'
    {0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00}, // '3'
    {0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00}, // '4'
    {0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00}, // '5'
    {0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00}, // '6'
    {0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00}, // '7'
    {0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00}, // '8'
    {0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00}, // '9'
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // ':'
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x06, 0x00}, // ';'
    {0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00}, // '<'
    {0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00}, // '='
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00}, // '>'
    {0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00}, // '?'
    {0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00}, // '@'
    {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00}, // 'A'
    {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00}, // 'B'
    {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00}, // 'C'
    {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00}, // 'D'
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00}, // 'E'
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00}, // 'F'
    {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00}, // 'G'
    {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00}, // 'H'
    {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 'I'
    {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00}, // 'J'
    {0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00}, // 'K'
    {0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00}, // 'L'
    {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00}, // 'M'
    {0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00}, // 'N'
    {0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00}, // 'O'
    {0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00}, // 'P'
    {0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00}, // 'Q'
    {0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00}, // 'R'
    {0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00}, // 'S'
    {0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 'T'
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00}, // 'U'
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // 'V'
    {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}, // 'W'
    {0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00}, // 'X'
    {0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00}, // 'Y'
    {0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00}, // 'Z'
    // Add more characters as needed... (for now just numbers and basic punctuation)
};

SSD1315::SSD1315(i2c_inst_t *i2c, uint sda, uint scl) : i2c(i2c)
{
    // Note: I2C initialization should be done externally
    memset(buffer, 0, sizeof(buffer));
}

void SSD1315::sendCommand(uint8_t cmd)
{
    uint8_t buf[2] = {0x00, cmd};
    i2c_write_blocking(i2c, OLED_ADDR, buf, 2, false);
}

void SSD1315::sendData(uint8_t *data, size_t len)
{
    uint8_t buf[len + 1];
    buf[0] = 0x40;
    memcpy(buf + 1, data, len);
    i2c_write_blocking(i2c, OLED_ADDR, buf, len + 1, false);
}

void SSD1315::init()
{
    sendCommand(0xAE); // Display off
    sendCommand(0xD5);
    sendCommand(0x80); // Set display clock divide ratio
    sendCommand(0xA8);
    sendCommand(0x3F); // Set multiplex ratio
    sendCommand(0xD3);
    sendCommand(0x00); // Set display offset
    sendCommand(0x40); // Set start line address
    sendCommand(0x8D);
    sendCommand(0x14); // Charge pump
    sendCommand(0x20);
    sendCommand(0x00); // Memory addressing mode
    sendCommand(0xA1); // Set segment re-map
    sendCommand(0xC8); // Set COM output scan direction
    sendCommand(0xDA);
    sendCommand(0x12); // Set COM pins hardware configuration
    sendCommand(0x81);
    sendCommand(0xCF); // Set contrast control
    sendCommand(0xD9);
    sendCommand(0xF1); // Set pre-charge period
    sendCommand(0xDB);
    sendCommand(0x40); // Set VCOMH
    sendCommand(0xA4); // Entire display on
    sendCommand(0xA6); // Set normal display
    sendCommand(0xAF); // Display on

    clear();
}

void SSD1315::clear()
{
    memset(buffer, 0, sizeof(buffer));
    display();
}

void SSD1315::display()
{
    for (int page = 0; page < PAGES; ++page)
    {
        sendCommand(0xB0 + page); // Set page address
        sendCommand(0x00);        // Set lower column start address
        sendCommand(0x10);        // Set higher column start address
        sendData(&buffer[page * WIDTH], WIDTH);
    }
}

void SSD1315::setPixel(int x, int y, bool on)
{
    if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT)
    {
        int page = y / 8;
        int bit = y % 8;
        int index = page * WIDTH + x;

        if (on)
        {
            buffer[index] |= (1 << bit);
        }
        else
        {
            buffer[index] &= ~(1 << bit);
        }
    }
}

void SSD1315::drawChar(int x, int y, char c)
{
    if (c < 32 || c > 126)
        return; // Only printable ASCII

    const uint8_t *char_data = font8x8[c - 32];

    for (int i = 0; i < 8; i++)
    {
        for (int j = 0; j < 8; j++)
        {
            if (char_data[i] & (1 << j))
            {
                setPixel(x + j, y + i, true);
            }
        }
    }
}

void SSD1315::drawString(int x, int y, const char *str)
{
    int pos_x = x;
    while (*str && pos_x < WIDTH - 8)
    {
        drawChar(pos_x, y, *str);
        pos_x += 8;
        str++;
    }
}

void SSD1315::drawStringCentered(int y, const char *str)
{
    int len = strlen(str);
    int x = (WIDTH - len * 8) / 2;
    drawString(x, y, str);
}

void SSD1315::clearRect(int x, int y, int w, int h)
{
    // Clamp and normalize rectangle
    if (w <= 0 || h <= 0)
        return;
    int x0 = x;
    int y0 = y;
    if (x0 < 0)
    {
        w += x0;
        x0 = 0;
    }
    if (y0 < 0)
    {
        h += y0;
        y0 = 0;
    }
    int x1 = x0 + w;
    int y1 = y0 + h;
    if (x1 > WIDTH)
        x1 = WIDTH;
    if (y1 > HEIGHT)
        y1 = HEIGHT;
    if (x1 <= x0 || y1 <= y0)
        return;

    // Clear bits in the framebuffer for each scanline in the rect
    for (int yy = y0; yy < y1; ++yy)
    {
        int page = yy / 8;
        int bit = yy % 8;
        int rowIndex = page * WIDTH;
        uint8_t mask = (uint8_t)~(1u << bit);
        for (int xx = x0; xx < x1; ++xx)
        {
            buffer[rowIndex + xx] &= mask;
        }
    }
}